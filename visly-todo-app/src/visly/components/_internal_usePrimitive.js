// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
/* tslint:disable */
/* eslint-disable */
import { useState, useEffect, useMemo } from "react";
import { mergeProps } from "@visly/core";
import {
  InteractionState,
  useIsInside,
  noop,
  exists,
  getRootClasses,
  stylesForState,
  shallowPick,
} from "./_internal_utils";
export const useMouseHandler = (args) => {
  const { isInside, setPressed, setHovered } = args;
  const [isHandlingEvents, setIsHandlingEvents] = useState(false);
  const handler = createMouseHandler({
    isInside,
    setHovered,
    setIsHandlingEvents,
    setPressed,
  });
  useEffect(() => {
    const resetPressedState = () => {
      if (isHandlingEvents) {
        setIsHandlingEvents(false);
        setPressed(false);
      }
    };

    document.addEventListener("mouseup", resetPressedState);
    return () => {
      document.removeEventListener("mouseup", resetPressedState);
    };
  }, [isHandlingEvents, setIsHandlingEvents, setPressed]);
  return handler;
};
export const createMouseHandler = ({
  isInside,
  setIsHandlingEvents,
  setPressed,
  setHovered,
}) => {
  return {
    onMouseEnter: (event) => setHovered(isInside(event.target)),
    onMouseLeave: (_) => setHovered(false),
    onMouseMove: (event) => setHovered(isInside(event.target)),
    onMouseDown: (event) => {
      setIsHandlingEvents(isInside(event.target));
      setPressed(isInside(event.target));
      event.stopPropagation();
    },
    onMouseUp: (_) => setPressed(false),
  };
};

function useInteractionState(props) {
  const {
    disabled = false,
    _hovered = false,
    _focused = false,
    _pressed = false,
  } = props;
  const [hovered, setHovered] = useState(false);
  const [focused, setFocused] = useState(false);
  const [pressed, setPressed] = useState(false);
  const pairs = [
    [InteractionState.None, true],
    [InteractionState.Hover, _hovered || hovered],
    [InteractionState.Focus, _focused || focused],
    [InteractionState.Pressed, _pressed || pressed],
  ];
  const states = disabled
    ? [InteractionState.None, InteractionState.Disabled]
    : pairs.filter((s) => s[1]).map((s) => s[0]);
  return {
    states,
    setFocused,
    setPressed,
    setHovered,
  };
}

function hasDisabledState(states) {
  return states.includes(InteractionState.Disabled);
}

function useInteractionStateHandlers(
  ref,
  props,
  isInterative,
  ignoreFocusHandling
) {
  const { onClick } = props;
  const { states, setFocused, setHovered, setPressed } = useInteractionState(
    props
  );
  const isInside = useIsInside(ref);
  const mouseHandler = useMouseHandler({
    isInside,
    setHovered,
    setPressed,
  });
  const interactionStateHandlers = {
    onFocus: ignoreFocusHandling
      ? noop
      : (e) => {
          setFocused(true);
          e.stopPropagation();
        },
    onBlur: ignoreFocusHandling
      ? noop
      : () => {
          setFocused(false);
        },
    onClick: (e) => {
      if (exists(onClick)) {
        e.stopPropagation();
      }
    },
    ...mouseHandler,
  };

  if (hasDisabledState(states) || !isInterative) {
    return {
      states,
      setFocused: noop,
      handlers: {},
    };
  }

  return {
    states,
    setFocused,
    handlers: interactionStateHandlers,
  };
}

function filterReactProps(props, states) {
  const reactProps = shallowPick(
    {
      tabIndex: props.tabIndex,
      role: props.role,
      onAuxClick: props.onAuxClick,
      onAuxClickCapture: props.onAuxClickCapture,
      onClick: props.onClick,
      onClickCapture: props.onClickCapture,
      onContextMenu: props.onContextMenu,
      onContextMenuCapture: props.onContextMenuCapture,
      onDoubleClick: props.onDoubleClick,
      onDoubleClickCapture: props.onDoubleClickCapture,
      onDrag: props.onDrag,
      onDragCapture: props.onDragCapture,
      onDragEnd: props.onDragEnd,
      onDragEndCapture: props.onDragEndCapture,
      onDragEnter: props.onDragEnter,
      onDragEnterCapture: props.onDragEnterCapture,
      onDragExit: props.onDragExit,
      onDragExitCapture: props.onDragExitCapture,
      onDragLeave: props.onDragLeave,
      onDragLeaveCapture: props.onDragLeaveCapture,
      onDragOver: props.onDragOver,
      onDragOverCapture: props.onDragOverCapture,
      onDragStart: props.onDragStart,
      onDragStartCapture: props.onDragStartCapture,
      onDrop: props.onDrop,
      onDropCapture: props.onDropCapture,
      onMouseDown: props.onMouseDown,
      onMouseDownCapture: props.onMouseDownCapture,
      onMouseEnter: props.onMouseEnter,
      onMouseLeave: props.onMouseLeave,
      onMouseMove: props.onMouseMove,
      onMouseMoveCapture: props.onMouseMoveCapture,
      onMouseOut: props.onMouseOut,
      onMouseOutCapture: props.onMouseOutCapture,
      onMouseOver: props.onMouseOver,
      onMouseOverCapture: props.onMouseOverCapture,
      onMouseUp: props.onMouseUp,
      onMouseUpCapture: props.onMouseUpCapture,
      onTouchCancel: props.onTouchCancel,
      onTouchCancelCapture: props.onTouchCancelCapture,
      onTouchEnd: props.onTouchEnd,
      onTouchEndCapture: props.onTouchEndCapture,
      onTouchMove: props.onTouchMove,
      onTouchMoveCapture: props.onTouchMoveCapture,
      onTouchStart: props.onTouchStart,
      onTouchStartCapture: props.onTouchStartCapture,
      onPointerDown: props.onPointerDown,
      onPointerDownCapture: props.onPointerDownCapture,
      onPointerMove: props.onPointerMove,
      onPointerMoveCapture: props.onPointerMoveCapture,
      onPointerUp: props.onPointerUp,
      onPointerUpCapture: props.onPointerUpCapture,
      onPointerCancel: props.onPointerCancel,
      onPointerCancelCapture: props.onPointerCancelCapture,
      onPointerEnter: props.onPointerEnter,
      onPointerLeave: props.onPointerLeave,
      onPointerOver: props.onPointerOver,
      onPointerOverCapture: props.onPointerOverCapture,
      onPointerOut: props.onPointerOut,
      onPointerOutCapture: props.onPointerOutCapture,
      onGotPointerCapture: props.onGotPointerCapture,
      onGotPointerCaptureCapture: props.onGotPointerCaptureCapture,
      onLostPointerCapture: props.onLostPointerCapture,
      onLostPointerCaptureCapture: props.onLostPointerCaptureCapture,
      onScroll: props.onScroll,
      onScrollCapture: props.onScrollCapture,
      onWheel: props.onWheel,
      onWheelCapture: props.onWheelCapture,
      onKeyDown: props.onKeyDown,
      onKeyDownCapture: props.onKeyDownCapture,
      onKeyPress: props.onKeyPress,
      onKeyPressCapture: props.onKeyPressCapture,
      onKeyUp: props.onKeyUp,
      onKeyUpCapture: props.onKeyUpCapture,
      onFocus: props.onFocus,
      onFocusCapture: props.onFocusCapture,
      onBlur: props.onBlur,
      onBlurCapture: props.onBlurCapture,
    },
    exists
  );

  if (states.includes(InteractionState.Disabled)) {
    for (const key in reactProps) {
      if (key.startsWith("on")) {
        delete reactProps[key];
      }
    }
  }

  return reactProps;
}

export function usePrimitive({
  ref,
  props,
  ignoreFocusHandling = false,
  isFocusVisible = false,
  isPressed,
  variants = [],
  isInteractive = true,
}) {
  const { internal, style: _style = {}, className, innerRef, testId } = props;
  const { states: _states, handlers, setFocused } = useInteractionStateHandlers(
    ref,
    props,
    isInteractive,
    ignoreFocusHandling
  );
  const states = [..._states];

  if (isFocusVisible) {
    states.push(InteractionState.Focus);
  }

  if (isPressed) {
    states.push(InteractionState.Pressed);
  }

  const activeVariants = [...variants, ...internal.activeVariants];
  const vislyClasses = getRootClasses({
    scope: internal.scope,
    layerId: internal.layerId,
    setVariantProps: activeVariants,
    states,
  });
  const reactProps = filterReactProps(props, states);
  const noSelectStyles = exists(props.onClick)
    ? {
        userSelect: "none",
        WebkitUserSelect: "none",
        KhtmlUserSelect: "none",
        MozUserSelect: "none",
      }
    : {};
  const style = mergeProps(_style, noSelectStyles);
  const vislyProps = mergeProps(reactProps, handlers, {
    className: [className, vislyClasses].filter(exists).join(" "),
  });
  const isDisabled = hasDisabledState(states);
  return useMemo(
    () => ({
      states,
      style,
      variants: activeVariants,
      innerRef,
      testId,
      vislyProps,
      values: stylesForState({
        styles: internal.styles,
        states,
        variants: activeVariants,
      }),
      isDisabled,
      setFocused,
    }),
    [
      states,
      style,
      activeVariants,
      innerRef,
      testId,
      internal.styles,
      vislyProps,
      isDisabled,
      setFocused,
    ]
  );
}
